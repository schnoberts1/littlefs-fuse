
[cases.test_interspersed_files]
defines.SIZE = [10, 100]
defines.FILES = [4, 10, 26] 
code = '''
    dbc_lfs_t lfs;
    dbc_lfs_file_t files[FILES];
    const char alphas[] = "abcdefghijklmnopqrstuvwxyz";
    dbc_lfs_format(&lfs, cfg) => 0;
    dbc_lfs_mount(&lfs, cfg) => 0;
    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_file_open(&lfs, &files[j], path,
                DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT | DBC_LFS_O_EXCL) => 0;
    }

    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < FILES; j++) {
            dbc_lfs_file_write(&lfs, &files[j], &alphas[j], 1) => 1;
        }
    }

    for (int j = 0; j < FILES; j++) {
        dbc_lfs_file_close(&lfs, &files[j]);
    }

    dbc_lfs_dir_t dir;
    dbc_lfs_dir_open(&lfs, &dir, "/") => 0;
    struct dbc_lfs_info info;
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(strcmp(info.name, path) == 0);
        assert(info.type == DBC_LFS_TYPE_REG);
        assert(info.size == SIZE);
    }
    dbc_lfs_dir_read(&lfs, &dir, &info) => 0;
    dbc_lfs_dir_close(&lfs, &dir) => 0;

    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_file_open(&lfs, &files[j], path, DBC_LFS_O_RDONLY) => 0;
    }

    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < FILES; j++) {
            uint8_t buffer[1024];
            dbc_lfs_file_read(&lfs, &files[j], buffer, 1) => 1;
            assert(buffer[0] == alphas[j]);
        }
    }

    for (int j = 0; j < FILES; j++) {
        dbc_lfs_file_close(&lfs, &files[j]);
    }
    
    dbc_lfs_unmount(&lfs) => 0;
'''

[cases.test_interspersed_remove_files]
defines.SIZE = [10, 100]
defines.FILES = [4, 10, 26]
code = '''
    dbc_lfs_t lfs;
    const char alphas[] = "abcdefghijklmnopqrstuvwxyz";
    dbc_lfs_format(&lfs, cfg) => 0;
    dbc_lfs_mount(&lfs, cfg) => 0;
    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_file_t file;
        dbc_lfs_file_open(&lfs, &file, path,
                DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT | DBC_LFS_O_EXCL) => 0;
        for (int i = 0; i < SIZE; i++) {
            dbc_lfs_file_write(&lfs, &file, &alphas[j], 1) => 1;
        }
        dbc_lfs_file_close(&lfs, &file);
    }
    dbc_lfs_unmount(&lfs) => 0;

    dbc_lfs_mount(&lfs, cfg) => 0;
    dbc_lfs_file_t file;
    dbc_lfs_file_open(&lfs, &file, "zzz", DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT) => 0;
    for (int j = 0; j < FILES; j++) {
        dbc_lfs_file_write(&lfs, &file, (const void*)"~", 1) => 1;
        dbc_lfs_file_sync(&lfs, &file) => 0;

        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_remove(&lfs, path) => 0;
    }
    dbc_lfs_file_close(&lfs, &file);

    dbc_lfs_dir_t dir;
    dbc_lfs_dir_open(&lfs, &dir, "/") => 0;
    struct dbc_lfs_info info;
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "zzz") == 0);
    assert(info.type == DBC_LFS_TYPE_REG);
    assert(info.size == FILES);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 0;
    dbc_lfs_dir_close(&lfs, &dir) => 0;

    dbc_lfs_file_open(&lfs, &file, "zzz", DBC_LFS_O_RDONLY) => 0;
    for (int i = 0; i < FILES; i++) {
        uint8_t buffer[1024];
        dbc_lfs_file_read(&lfs, &file, buffer, 1) => 1;
        assert(buffer[0] == '~');
    }
    dbc_lfs_file_close(&lfs, &file);
    
    dbc_lfs_unmount(&lfs) => 0;
'''

[cases.test_interspersed_remove_inconveniently]
defines.SIZE = [10, 100]
code = '''
    dbc_lfs_t lfs;
    dbc_lfs_format(&lfs, cfg) => 0;
    dbc_lfs_mount(&lfs, cfg) => 0;
    dbc_lfs_file_t files[3];
    dbc_lfs_file_open(&lfs, &files[0], "e", DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT) => 0;
    dbc_lfs_file_open(&lfs, &files[1], "f", DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT) => 0;
    dbc_lfs_file_open(&lfs, &files[2], "g", DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT) => 0;

    for (int i = 0; i < SIZE/2; i++) {
        dbc_lfs_file_write(&lfs, &files[0], (const void*)"e", 1) => 1;
        dbc_lfs_file_write(&lfs, &files[1], (const void*)"f", 1) => 1;
        dbc_lfs_file_write(&lfs, &files[2], (const void*)"g", 1) => 1;
    }

    dbc_lfs_remove(&lfs, "f") => 0;

    for (int i = 0; i < SIZE/2; i++) {
        dbc_lfs_file_write(&lfs, &files[0], (const void*)"e", 1) => 1;
        dbc_lfs_file_write(&lfs, &files[1], (const void*)"f", 1) => 1;
        dbc_lfs_file_write(&lfs, &files[2], (const void*)"g", 1) => 1;
    }

    dbc_lfs_file_close(&lfs, &files[0]);
    dbc_lfs_file_close(&lfs, &files[1]);
    dbc_lfs_file_close(&lfs, &files[2]);

    dbc_lfs_dir_t dir;
    dbc_lfs_dir_open(&lfs, &dir, "/") => 0;
    struct dbc_lfs_info info;
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "e") == 0);
    assert(info.type == DBC_LFS_TYPE_REG);
    assert(info.size == SIZE);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "g") == 0);
    assert(info.type == DBC_LFS_TYPE_REG);
    assert(info.size == SIZE);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 0;
    dbc_lfs_dir_close(&lfs, &dir) => 0;

    dbc_lfs_file_open(&lfs, &files[0], "e", DBC_LFS_O_RDONLY) => 0;
    dbc_lfs_file_open(&lfs, &files[1], "g", DBC_LFS_O_RDONLY) => 0;
    for (int i = 0; i < SIZE; i++) {
        uint8_t buffer[1024];
        dbc_lfs_file_read(&lfs, &files[0], buffer, 1) => 1;
        assert(buffer[0] == 'e');
        dbc_lfs_file_read(&lfs, &files[1], buffer, 1) => 1;
        assert(buffer[0] == 'g');
    }
    dbc_lfs_file_close(&lfs, &files[0]);
    dbc_lfs_file_close(&lfs, &files[1]);
    
    dbc_lfs_unmount(&lfs) => 0;
'''

[cases.test_interspersed_reentrant_files]
defines.SIZE = [10, 100]
defines.FILES = [4, 10, 26] 
reentrant = true
defines.POWERLOSS_BEHAVIOR = [
    'DBC_LFS_EMUBD_POWERLOSS_NOOP',
    'DBC_LFS_EMUBD_POWERLOSS_OOO',
]
code = '''
    dbc_lfs_t lfs;
    dbc_lfs_file_t files[FILES];
    const char alphas[] = "abcdefghijklmnopqrstuvwxyz";

    int err = dbc_lfs_mount(&lfs, cfg);
    if (err) {
        dbc_lfs_format(&lfs, cfg) => 0;
        dbc_lfs_mount(&lfs, cfg) => 0;
    }

    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_file_open(&lfs, &files[j], path,
                DBC_LFS_O_WRONLY | DBC_LFS_O_CREAT | DBC_LFS_O_APPEND) => 0;
    }

    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < FILES; j++) {
            dbc_lfs_ssize_t size = dbc_lfs_file_size(&lfs, &files[j]);
            assert(size >= 0);
            if ((int)size <= i) {
                dbc_lfs_file_write(&lfs, &files[j], &alphas[j], 1) => 1;
                dbc_lfs_file_sync(&lfs, &files[j]) => 0;
            }
        }
    }

    for (int j = 0; j < FILES; j++) {
        dbc_lfs_file_close(&lfs, &files[j]);
    }

    dbc_lfs_dir_t dir;
    dbc_lfs_dir_open(&lfs, &dir, "/") => 0;
    struct dbc_lfs_info info;
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == DBC_LFS_TYPE_DIR);
    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(strcmp(info.name, path) == 0);
        assert(info.type == DBC_LFS_TYPE_REG);
        assert(info.size == SIZE);
    }
    dbc_lfs_dir_read(&lfs, &dir, &info) => 0;
    dbc_lfs_dir_close(&lfs, &dir) => 0;

    for (int j = 0; j < FILES; j++) {
        char path[1024];
        sprintf(path, "%c", alphas[j]);
        dbc_lfs_file_open(&lfs, &files[j], path, DBC_LFS_O_RDONLY) => 0;
    }

    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < FILES; j++) {
            uint8_t buffer[1024];
            dbc_lfs_file_read(&lfs, &files[j], buffer, 1) => 1;
            assert(buffer[0] == alphas[j]);
        }
    }

    for (int j = 0; j < FILES; j++) {
        dbc_lfs_file_close(&lfs, &files[j]);
    }
    
    dbc_lfs_unmount(&lfs) => 0;
'''
